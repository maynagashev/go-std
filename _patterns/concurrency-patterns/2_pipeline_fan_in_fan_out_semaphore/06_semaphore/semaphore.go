/*
Вы уже знакомы с мьютексами и знаете, что мьютекс позволяет только одному потоку обращаться к ресурсу за раз.
Семафор позволяет N потокам обращаться к ресурсу за раз.
*/

package main

import (
	"log"
	"sync"
	"time"
)

// Semaphore структура семафора
type Semaphore struct {
	semaCh chan struct{}
}

// NewSemaphore создает семафор с буферизованным каналом емкостью maxReq
func NewSemaphore(maxReq int) *Semaphore {
	return &Semaphore{
		semaCh: make(chan struct{}, maxReq),
	}
}

// когда горутина запускается, отправляем пустую структуру в канал semaCh
func (s *Semaphore) Acquire() {
	s.semaCh <- struct{}{}
}

// когда горутина завершается, из канала semaCh убирается пустая структура
func (s *Semaphore) Release() {
	<-s.semaCh
}

/*
2024/06/01 11:01:02 Запущен рабочий %d 9
2024/06/01 11:01:02 Запущен рабочий %d 4

2024/06/01 11:01:03 Запущен рабочий %d 6
2024/06/01 11:01:03 Запущен рабочий %d 5

2024/06/01 11:01:04 Запущен рабочий %d 7
2024/06/01 11:01:04 Запущен рабочий %d 0

2024/06/01 11:01:05 Запущен рабочий %d 3
2024/06/01 11:01:05 Запущен рабочий %d 8

2024/06/01 11:01:06 Запущен рабочий %d 2
2024/06/01 11:01:06 Запущен рабочий %d 1
*/
func main() {
	// чтобы дождаться всех горутин
	var wg sync.WaitGroup

	// создаём семафор емкостью 2: он будет пропускать только 2 горутины
	semaphore := NewSemaphore(2)

	// создаем 10 горутин
	for idx := 0; idx < 10; idx++ {
		wg.Add(1)

		// горутина в которую помещаем её порядковый номер
		go func(taskID int) {
			// отправляем в канал семафора пустую структуру
			semaphore.Acquire()

			// откладываем уменьшение счетчика в WaitGroup, когда завершится горутина
			defer wg.Done()

			// забираем из канала семафора пустую структуру, дав возможность запуститься другим горутинам
			defer semaphore.Release()

			log.Println("Запущен рабочий %d", taskID)

			time.Sleep(1 * time.Second)
		}(idx)
	}

	// ждём завершения всех горутин
	wg.Wait()
}
